# 1. 컴퓨터의 기본 구성
## 하드웨어의 구성
 : `중앙처리장치(CPU)`, `메인메모리`, `입출력장치`, `저장장치`    
 &rarr; CPU와 메인메모리를 제외하면 주변장치
 * `제1저장장치` : 메인메모리
 * `제2저장장치` : 보조저장장치

## 폰노이만 구조 (현대의 대부분의 컴퓨터 구조)
 : CPU, 메모리, 입출력장치, 저장장치가 버스로 연결되어있는 구조    
 &rarr; *데이터를 **메모리**에 올려 실행하는 구조*   
 &rarr; 하드웨어는 그대로 둔 채 프로그램만 교체하기 위한 것   
 
## 관련 용어
* `클록(clock)` : CPU의 속도와 관련된 단위. CPU는 클록이 일정하게 만드는 틱(tick) 간격에 맞춰 연산을 수행한다.
* `헤르츠(Hz)` : 클록틱이 발생하는 속도를 나타내는 단위. ex 1초에 틱 한번 : 1Hz (1초에 한번 데이터 이동을 한다)
* `시스템 버스` : 메모리 - 주변장치를 연결하는 버스
* `CPU 내부 버스` : CPU 내부 장치를 연결하는 버스로, CPU의 클록과 속도가 같다.   
&rarr; 시스템 버스와 CPU 내부 버스의 속도 차이로 인해 작업이 지연되는 문제가 발생함

# 2. CPU와 메모리
## CPU의 구성
* `산술논리 연산장치(Arithmetic and Logic Unit, ALU)` : CPU에서 데이터를 연산하는 장치 (산술 연산 및 논리 연산)    
* `제어장치(Control Unit)` : CPU에서 작업을 지시하는 부분    
* `레지스터(Register)`: CPU내에 데이터를 임시로 보관하는 곳    
 
 ## CPU의 명령어 처리 과정
 ```assembly
 LOAD mem(100), register 2; // 100번지에 있는 데이터를 2번 레지스터로 가져와라
 LOAD mem(120), register 3;
 ADD register 5, register 2, register 3; // 5번 레지스터에 2번 레지스터 + 3번 레지스트의 결과값을 저장해라
 MOVE register 5, mem(160); // 160번지에 5번 레지스터의 데이터값을 저장해라
 ```
 * 레지스터에는 필요한 연산을 위한 데이터를 가져온 후 연산하고 임시로 데이터값을 저장한다. 이후에 결과값은 메모리로 옮겨 저장한다.
 * 제어장치는 명령어를 해석해 제어신호를 보내고, CPU 내의 데이터 흐름을 조절한다.
 <img src = "https://user-images.githubusercontent.com/46108770/162961943-3453b8b6-eedc-4896-8614-4f9cceca6e4a.jpeg" width = 400>     
 
 ## 레지스터의 종류
 ### 일반 레지스터 (사용자 가시 레지스터, 사용자에 의해 변경됨)
 * `데이터 레지스터(DR, Data Register)` : 대부분의 레지스터로, 메모리에서 가져온 데이터를 임시로 보관. 일반 레지스터라고도 함
 * `주소 레지스터(AR, Address Register)` : 데이터나 명령어가 저장된 *주소*를 저장하는 레지스터

 ### 특수 레지스터(사용자 불가시 레지스터)
 * `프로그램 카운터(PC, Program Counter)` : 다음에 실행할 명령어의 주소를 기억하는 레지스터로, 제어장치에 알려준다. 명령어 포인터라고도 함
 * `명령어 레지스터(IR, Instruction Register)` : 현재 실행중인 명령어를 저장하는 레지스터
 * `메모리 주소 레지스터(MAR, Memory Address Register)` : 필요한 데이터의 메모리 주소를 넣으면 메모리 관리자가 이를 인식해 데이터를 레지스터에 제어장치가 가져오거나, 메모리에 저장한다.
 * `메모리 버퍼 레지스터(MBR, Memory Buffer Register)` : MAR과 함께 동작, 이동할 데이터를 임시로 저장한다.
 * `프로그램 상태 레지스터` : 연산 결과(양수, 음수 등)을 저장.
 
 ## 버스의 종류
 * `제어 버스(Control Bus)` : 작업을 지시하는 제어 신호가 오고감 (읽기 신호, 쓰기 신호 등), CPU의 제어 장치와 연결
 * `주소 버스(Address Bus)` : 메모리의 데이터를 읽고 쓸 때 어느 위치에서 작업할지 알려주는 주소 정보가 오고감, MAR과 연결, 단방향(CPU -> 메모리 및 주변장치)
 * `데이터 버스(Data Bus)` : 데이터가 오고감, MBR과 연결, 양방향
 <img src = "https://user-images.githubusercontent.com/46108770/162967510-62cda07a-80fa-4966-bf0a-092f10bcdaa6.jpeg" width = 400>

 ## 버스 관련 용어
 * 버스의 대역폭(bandwidth) : 버스가 한 번에 전달할 수 있는 데이터의 최대 크기, CPU가 한 번에 처리할 수 있는 데이터의 크기와 같다.
 &rarr; 버스의 대역폭 == 레지스터의 크기 == 메모리에 한 번에 저장할 수 있는 데이터의 크기
 * 워드(Word) : CPU가 한 번에 처리할 수 있는 데이터의 최대 크기 (ex. 32bit, 64bit) == 버스의 대역폭과 메모리에 한 번에 저장되는 단위
 
 ## 메모리 보호
  : 메모리 소자의 크기는 *1bit*(0, 1), 메모리 주소는 *바이트* 단위, 데이터를 읽고 쓸 때는 *워드* 단위로 움직인다.
  * 메모리 보호 : 운영체제도 소프트웨어이므로, 사용자 작업이 진행될 때는 운영체제 작업이 잠시 중단된다.   
  &rarr; OS가 중단된 상태에서 메모리를 사용자의 작업으로부터 보호하기 위해 하드웨어인 레지스터의 도움이 필요하다.   
  &rarr; 메모리 시작 주소를 `경계 레지스터`에, 끝나는 주소를 `한계 레지스터`에 저장해 두고 사용자의 작업이 진행되는 동안 해당 범위를 벗어나는지 검사해서 인터럽트를 발생시키는 것.
 
 ## 부팅(Booting)
 : 컴퓨터를 켰을 때 운영체제를 메모리에 올리는 과정   
 `바이오스(롬)` &rarr; `하드웨어 점검` &rarr; `메모리에 부트스트랩 코드 올려 실행` &rarr; `부트스트랩 코드가 운영체제 프로세스 실행`   
 * `마스터 부트 레코드` : 하드디스크의 첫 번째 섹터로, 부트스트랩 코드가 저장되어 있음.
 * `부트스트랩` : 운영체제를 메모리로 가져와 실행하는 역할을 하는 작은 프로그램
 &rarr; 윈도우즈로 부팅할지, mac os로 부팅할지 선택하는 화면이 부트스트랩 코드가 실행된 화면

# 3. 컴퓨터 성능 향상 기술
 : 현대 컴퓨터 구조의 가장 큰 문제는 CPU - 메모리 - 주변 장치의 작업 속도가 다르기 때문에 발생하는 지연
 
 ## 버퍼(Buffer)
  : 속도 차이가 있는 두 장치 사이에서 일정량의 데이터를 모아 옮겨 속도 차이를 완화하는 장치
  * `메모리 버퍼` : 메모리 - 하드디스크 사이의 속도 차이를 완화하기 위한 버퍼
  * `스풀(Spool)` : CPU - 입출력장치 사이의 소프트웨어적인 버퍼로, CPU가 입출력 데이터를 하드디스크의 스풀러 공간에 저장함으로써 CPU와 입출력장치가 독립적으로 동작할 수 있게 함.
   &rarr; 단, 다른 버퍼와 다르게 스풀러는 프로그램 간 버퍼가 배타적이다. 즉, 버퍼 하나에 하나의 프로그램만 데이터를 넣을 수 있는 것
 
 ## 캐시(Cache)
  : CPU - 메모리 사이의 속도 차이를 완하하기 위해 메모리의 데이터를 미리 가져다두는(prefetch) 임시 저장소.
  * `캐시 히트(Cache hit)` : CPU가 캐시에서 원하는 데이터를 찾은 경우
  * `캐시 미스(Cache miss)` : CPU가 캐시에서 원하는 데이터를 찾지 못한 경우
  * `캐시 적중률(Cache hit ratio)` : 캐시 히트가 된 비율
  * `지역성 이론(locality)` : 캐시를 늘리는 데는 한계가 존재하므로, 캐시 적중률을 높이기 위해 많이 사용되는 데이터를 캐시에 가져오는 방법. 현재 위치에 가까운 데이터가 더 많이 사용될 것이라고 보는 것이 지역성 이론
  * `즉시 쓰기와 지연 쓰기` : 캐시에 있는 데이터가 변경되면 메모리의 원래 데이터를 변경해야 하는데, 즉시 쓰기와 지연 쓰기(변경된 내용을 주기적으로 반영)의 방법이 있음.
  * `L1 캐시와 L2 캐시` : CPU의 레지스터에 직접 연결되는 L1 캐시(특수 캐시로, 명령어와 데이터를 가져오는 캐시), 메모리와 연결된 L2 캐시(일반 캐시로, 모든 자료를 가져오는 캐시)
   &rarr; L2 캐시에서 가져온 데이터 중 명령어와 데이터가 L1 캐시로 이동되는 것.
   
 ## 저장장치의 계층 구조
  : 컴퓨터의 성능을 향상시키기 위해 CPU로 갈 수록 빠르고 비싼 저장장치를 위치시킨다.   
 <img src = "https://user-images.githubusercontent.com/46108770/162974885-65cd64fc-3e7e-4f4b-8949-192509a855fa.jpeg" width = 400>
 
 
 ## 인터럽트(Interrupt)
  : CPU가 입출력에 관여하던 `폴링(Polling)` 방식에서 벗어나 데이터의 입출력을 독립적으로 구분하기 위한 방법.
  * `인터럽트(Interrupt)` : 입출력 관리자가 CPU에 보내는 완료 신호로, CPU는 완료 신호를 받으면 하던 일을 중단하고 옮겨진 데이터를 처리한다.
  * `직접 메모리 접근(Direct Memory Access, DMA)` : 메모리는 CPU만 접근 권한을 가지고 있으므로, 입출력 관리자는 직접 메로리 접근 제어기를 통해 메모리 접근 권한을 획득한다.    
   &rarr; DMA는 인터럽트 방식 시스템의 *필수 구성 요소*     
  * `메모리 매핑 입출력(Memorry Mapped I/O, MMIO)` : CPU가 사용하는 메모리 공간과 입출력 장치가 사용하는 메모리 공간을 분리해 관리하는 것.
  * `사이클 훔치기` : CPU와 입출력 장치가 동시에 메모리에 접근하는 경우, 속도가 빠른 CPU가 메모리 접근을 양보하는 것.

# 4. 병렬 처리(Parallel Processing)
 : 동시에 여러 개의 명령을 처리함으로써 CPU 작업의 능률을 올리는 방식     
 &rarr; CPU의 클록을 늘리면 발열 문제가, 캐시의 크기를 늘리면 비용 문제가 발생하기 때문.
 
 ## 병렬 처리 시 고려 사항
 * 상호 의존성이 없어야 한다.
 * 각 단계의 시간을 거의 일정하게 맞춰야 한다. : 병목 현상이 발생할 수 있기 때문
 * 병렬 처리의 깊이(depth of parallel processing)를 고려해야 한다 : 전체 작업 시간을 몇 단계로 나눌지도 함께 고려한다.
 
 ## 병렬 처리 기법
 * CPU 에서 명령어가 실행되는 과정(스레드, 각 단계는 한 클록에 이루어진다.)
 : `명령어 패치(Instruction Fetch, IF)` &rarr; `명령어 해석(Instruction Decode, ID)` &rarr; `실행(Excution, EX)` &rarr; `쓰기(Write Back, WB)`    
 1) `명령어 패치(Instruction Fetch, IF : 다음에 실행할 명령어를 명령어 레지스터에 저장
 2) `명령어 해석(Instruction Decode, ID) : 명령어를 해석한다.
 3) `실행(Excution, EX)` : 해석한 결과를 토대로 명령어를 실행한다.
 4) `쓰기(Write Back, WB)` : 실행된 결과를 메모리에 저장한다.
 
 ### 1. 파이프라인 기법(pipeline)
  : 명령어를 여러 단계로 분할해 각 단계를 동시에 처리하는 하드웨어를 독립적으로 구성하는 기법(하나의 코어에 여러 개의 스레드를 사용하는 것)   
  <img src = "https://user-images.githubusercontent.com/46108770/162978798-28bf4da6-bc44-443c-8e95-21b340d31455.jpeg" width = 400>
  * 파이프라인 위험 : 데이터 위험(데이터 의존성 &rarr; 명령어 단계를 지연해 해결), 제어 위험(PC값을 갑자기 변경되어 발생하는 위험, 분기 예측이나 지연으로 해결), 구조 위험(다른 명령어가 같은 자원에 접근 시 발생, 해결하기 어려움)

 ### 2. 슈퍼스칼라 기법(Super-Scalar)
 : 파이프라인을 처리할 수 있는 코어를 여러 개 구성해 `복수의 명령어`를 동시에 처리하는 방식, 대부분의 컴퓨터가 채택
 <img src = "https://user-images.githubusercontent.com/46108770/162979665-e19a8796-4970-49ec-8676-f262168b0255.jpeg" width = 400>
 
 ### 3. VLIW(Very Long Instruction Word) 기법
  : CPU가 병렬 처리를 지원하지 않을 경우 소프트웨어적으로 병렬 처리를 하는 방법.    
  & rarr; 명령어 실행 단계까 아닌 컴파일 단계엥서 컴파일러가 동시에 수행할 수 있는 명령어를 하나로 압축시킴으로써 병렬 처리가 이루어진다.

# + 무어의 법칙과 암달의 법칙
* `무어의 법칙` : CPU의 속도가 24개월마다 2배 빨라진다는 법칙으로, 현재는 그렇지 않음
* 멀티 스레드 : 하나의 코어에서 여러 개의 명령어를 실행하는 기술
* `암달의 법칙` : 주변장치의 향상 없이 CPU의 속도만 늘리면 병목 현상으로 인해 컴퓨터의 성능이 비례해서 빨라지지 않는다는 원칙   

 &larr; Chapter1 [운영체제의 개요](https://github.com/beansbin/TIL/blob/main/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/Chapter_1_%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C_%EA%B0%9C%EC%9A%94.md)
 
 &rarr; Chpater3 [프로세스와 스레드](https://github.com/beansbin/TIL/blob/main/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/Chapter_3_%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80_%EC%8A%A4%EB%A0%88%EB%93%9C.md)
