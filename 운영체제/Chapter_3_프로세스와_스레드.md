# Chapter 3. 프로세스와 스레드

## 프로세스의 개요

* **프로그램** : 저장장치에 저장되어있는 정적인 상태

* **프로세스 (=Task)**  : 실행을 위해 메모리에 올라온 동적인 상태

### 프로그램 &rarr; 프로세스로의 전환

 운영체제가 프로그램을 메모리에 가져오면서 프로세스 제어 블록(PCB)을 생성한다.    
 &rarr; *운영체제 자체도 커널 프로세스의 형태로 실행된다.*

### 프로세스의 5가지 상태 (현대 시분할 시스템)

<img src = "https://user-images.githubusercontent.com/46108770/167848261-33d146d3-b581-4f08-b224-ff1f5ded57a9.JPG" width=400>   

* **생성 상태** : 프로그램이 메모리에 올라와 PCB를 할당받은 상태   
  &rarr; PCB는 준비큐에서 대기
* **준비 상태** : 프로세스가 자기 차례를 기다리는 상태, CPU 스케쥴러가 실행될 프로세스 선택      
  &rarr; PCB는 준비큐에서 대기, CPU 스케쥴러가 dispatch(PID)로 실행될 PCB 선택
* **실행 상태** : dispatch된 프로세스가 정해진 타임 슬라이스동안 CPU에서 실행됨, 프로세스 사이의 문맥 교환 발생     
  &rarr; CPU의 개수만큼 프로세스가 실행됨, timeout(PID), 정상 종료는 exit(PID), 입출력 요청은 block(PID) 호출
* **대기 상태** : 실행 상태의 프로세스가 입출력을 요청할 경우 입출력이 완료될 때까지 기다리는 상태. 
  &rarr; 대기 프로세스는 입출력장치별로 마련된 큐에서 대기, 완료되면 wakeup(PID)로 인터럽트를 발생시켜 준비상태로 이동함.     
* **완료 상태** : 프로세스가 종료된 상태로, 메모리에서 제거되고 PCB도 삭제됨. 

**+ 휴식 상태와 보류 상태(비활성 상태)**
 : 조금 특별한 경우에 해당함

 * **휴식 상태** : 프로세스가 작업을 일시적으로 쉬고 있는 상태로, 프로세스는 여전히 메모리에 존재함 (ex. 유닉스 ctrl+z)     
 * **보류 상태** : 프로세스가 메모리에서 잠시 쫓겨나 스왑 영역에 보관된 상태   
   &rarr; 보류 상태의 프로세스는 미루어도 큰 문제가 없는 프로세스에 해당     



## 프로세스 제어 블록과 문맥 교환

### 프로세스 제어 블록 (PCB, Process Control Block)

<img src = "https://user-images.githubusercontent.com/46108770/167985140-33d1b503-470c-43d4-9d77-238db616a4eb.jpeg" width=200>  

* **포인터** : PCB의 첫 번째 블록에 저장, 준비큐 및 대기큐 구현에 사용    
* **프로세스 상태** : 생성, 준비, 실행, 대기, 보류 준비, 보류 대기의 상태를 PCB의 두 번째 블록에 저장    
* **프로세스 구분자** : PID(Process ID)    
* **프로그램 카운터** : 다음에 실행될 명령어의 위치를 저장    
* **프로세스 우선순위**        
* **각종 레지스터 정보** : 프로세스가 실행되는 중에 사용했던 각종 레지스터 값들의 중간값을 보관     
* **메모리 관리 정보** : 메모리 위치 정보(메모리 상에서의 프로세스 위치), 경계 레지스터 및 한계 레지스터 값 등     
* **할당된 자원 정보** : 입출력 자원 및 오픈 파일     
* **계정 정보** : 계정 번호, CPU 할당 시간 및 사용 시간 등      
* **부모 프로세스 및 자식 프로세스 구분자** : 부모 프로세스 구분자(PPID)와 자식 프로세스 구분자(CPID) 저장      


### 문맥 교환(Context Switching)

 CPU를 사용하던 프로세스가 나가고 새로운 프로세스를 받아들이는 작업, 즉 두 PCB를 교환하는 작업

 * 두 PCB 블록의 내용이 변경됨.   
   &rarr; 나가는 프로세스는 현재까지의 작업 내용 저장    
   &rarr; 들어오는 프로세스는 PCB의 내용으로 CPU가 다시 세팅됨.   

### 문맥 교환 절차

 타임아웃이 되면 P1의 PCB에 작업 내용이 저장되고, 준비 상태로 쫓겨난다.    
 그리고 P2의 PCB 값으로 CPU의 레지스터들이 채워져 작업이 시작된다.   
 &rarr; 인터럽트가 발생했을 때도 인터럽트 관리 프로세스로의 문맥 교환이 발생한다.      
<img src = "https://user-images.githubusercontent.com/46108770/167985133-b9e10b5c-c08a-4b60-90b5-856499ccbe9f.jpeg" width=500> 




## 프로세스의 연산

### 프로세스의 구조

<img src = "https://user-images.githubusercontent.com/46108770/167995082-2bdeffb4-b180-42f2-840c-36e6e867b49b.jpeg" width=400> 

* **코드 영역** : 실제 프로그램 코드가 존재하는 곳, 읽기 전용       
* **데이터 영역** : 코드가 실행되면서 사용하는 변수 및 파일 등 의 데이터를 모아놓은 곳, 읽기 및 쓰기 가능        
* **스택 영역** : 운영체제가 프로세스를 실행하기 위해 부수적으로 필요한 데이터들 모아놓은 곳, 사용자에게는 보이지 않음 (ex. 함수 호출 시 돌아올 위치 지정)        

### 프로세스의 생성 및 복사

1) **프로세스의 생성**
   : 운영체제가 프로그램을 실행하면 프로그램을 메모리로 가져와 코드 영역에 넣고 &rarr; PCB를 생성 &rarr; 데이터 영역 및 스택 영역 확보 후 프로세스를 실행        
2) **프로세스의 복사** - fork() 시스템 호출    
   : 실행 중인 프로세스로부터 새로운 프로세스를 복사하는 함수   

 * **동작과정** : 부모 프로세스 - 자식 프로세스 관계가 생성, PCB의 내용 중 PID, PPID, CPID 와 메모리 관련 정보를 제외한 모든 정보가 동일.    
   &rarr; 자식 프로세스가 없는 경우 PPID == -1    
 * **장점** : 생성 속도, 부모 프로세스의 자원을 추가 작업(초기화) 없이 상속 가능, 자식 프로세스를 종료하면 부모 프로세스가 자원을 정리함으로써 시스템을 효율적으로 관리 가능    
 * **예시**   
   : 부모 프로세스에는 0보다 큰 값을, 자식 프로세스에는 0을 반환. fork() 문 이전의 변수 및 파일 오픈은 자식 프로세스에 상속된다.   
   또한 부모와 자식 프로세스는 서로 독립적이다.   
   <img src = "https://user-images.githubusercontent.com/46108770/167995200-552c3f4c-71ce-461a-899d-826b53fd0b80.jpeg" width=400> 

### 프로세스의 전환 - exec() 시스템 호출

기존의 프로세스를 새로운 프로세스로 전환하는 함수로, 기존의 프로세스를 그대로 둔 채 내용만 바꾸는 것   

 * 프로세스의 구조체를 재활용 : 새로운 코드 영역만 가져오면 되기 때문, PCB와 메모리 영역, 부모-자식 관계를 그대로 활용 가능
 * **동작 과정** : PCB의 PID, PPID, CPID를 제외한 내용을 새로운 내용으로 변경, 데이터 영역 변경 및 스택 영역 리셋
 * **예시**   
   : execlp()가 실행되는 순간 자식 프로세스의 코드 영역이 mplayer로 변경, 부모 프로세스는 자식 프로세스를 wait()으로 기다림.   
     <img src = "https://user-images.githubusercontent.com/46108770/167995209-7defed46-bad6-4918-8ddb-779efc25fcc2.jpeg" width=400> 

### 프로세스의 계층 구조

* 프로세스를 계층 구조로 만들어 동시에 여러 작업을 처리하고 계층 간 책임을 부여함으로써 종료된 프로세스의 작업을 회수한다.    
* `미아 프로세스` : 프로세스가 종료된 후에도 비정상적으로 남아있는 프로세스, 자식의 exit()가 돌아갈 곳이 없는 경우에 해당, wait()을 사용해 미아 프로세스 생성을 방지 
* exit()나 return()문을 사용해 부모 프로세스에게 작업이 끝났음을 알리는 것이 좋음 &rarr; 부모 프로세스는 미뤄왔던 자원 정리 및 자식 프로세스와의 동기화를 할 수 있음.



## 스레드 (=Operation)

### 스레드의 개념

 CPU 스케줄러가 CPU에 전달하는 일 하나, 즉 CPU가 처리하는 작업의 단위    
 &rarr; 운영체제 입장에서의 작업 단위는 프로세스, CPU 입장에서의 작업 단위는 스레드인 것.   
 *일(job) : 여러 개의 프로세스, 한꺼번에 처리하는 것이 batch job인 것*     

 * 프로세스끼리는 약하게, 스레드끼리는 강하게 연결되어있다.   
 * `멀티태스킹` : 운영체제가 시간을 잘게 나누어 CPU에게 작업을 줄 때 사용하는 프로세스 운영 기법   
   &rarr; 독립적인 프로세스 간 데이터를 주고 받기 위해 프로세스 간 통신(IPC)를 이용한다. (ex. 워드프로세서 - 프린터 스풀러 간 출력 데이터)   
 * `멀티스레드` : 프로세스 내 작업을 여러 개의 스레드로 분할하는 프로세스 운영 기법, 시분할 시스템이 사용   
   &rarr; 스레드끼리 변수 및 파일을 공유, 전역 변수 및 함수 호출 등으로 통신함.  
 * `멀티프로세싱` : CPU 혹은 코어를 여러 개 사용해 여러 개의 스레드를 동시에 처리하는 작업 환경   
 * `CPU 멀티스레드` : 하드웨어적인 방법으로 하나의 CPU에서 여러 스레드를 동시에 처리하는 병렬 처리 기법

### 멀티스레드

* fork()의 낭비적인 요소 : 코드 영역, 데이터 영역의 일부가 메모리에 중복되어 존재하며 제거할 수 없다.    
  &rarr; 멀티태스킹의 여러개의 프로세스 대신 하나의 프로세스 내에서 코드, 데이터를 공유하며 여러 개의 스레드로 작업하는 멀티스레드를 사용하는 것   

1) 멀티스레드의 구조    
   <img src = "https://user-images.githubusercontent.com/46108770/168000811-91239ff9-9a72-4e9b-8535-6e53047364d4.jpeg" width=400>   

* **정적 영역** : 프로세스가 실행되는 동안 바뀌지 않는 영역           
* **동적 영역** : 스레드가 작업을 하면서 값이 바뀌거나 새로 만들어지거나 사라지는 영역    
  &rarr; 오늘날에는 fork() 대신 멀티 스레드 사용이 일반적.          

2) 멀티스레드 예시    
   <img src = "https://user-images.githubusercontent.com/46108770/168001056-862f00c9-33e4-452e-94c2-570653b29aeb.jpeg" width=400>        
   <img src = "https://user-images.githubusercontent.com/46108770/168001155-9332db90-0962-4f19-a262-015d3e7e76f4.jpeg" width=400>      
   &rarr; fork()를 호출해 멀티태스킹을 사용하는 경우

### 멀티스레드의 장단점

* 프로세스 내 공유가 가능한 부분을 제외하고 실행과 관련된 부분을 스레드로 나누어 자원의 중복 사용을 막을 수 있음.      
* 예시 - 비디오 플레이어의 입출력 스레드가 대기 상태에 있어도 재생 스레드는 실행 상태에 존재할 수 있음.     
* 응답성 향상 : 각 스레드가 독립적으로 진행되므로 한 스레드가 입출력 상태에 있어도 다른 스레드는 작업을 계속할 수 있음.     
* 자원 공유 : 원활한 작업 진행 가능    
* 효율성 향상 : 불필요한 자원의 중복 방지   
* 다중 CPU 지원    
* 단점 : 모든 스레드가 자원을 공유하므로 한 스레드에 문제가 생기면 전체 프로세스에 영향을 미침     
  &rarr; 크롬의 각 탭이 낭비 요소에도 불구하고 멀티 태스킹으로 진행되는 이유  




## 동적 할당 영역과 시스템 호출

### 프로세스의 동적 할당 영역

* **정적 할당 영역**(코드 영역, 데이터 영역) : 프로세스가 실행되기 직전에 위치와 크기가 결정되어 실행되는 동안 변하지 않음    
* **동적 할당 영역**(스택 영역, 힙 영역) : 프로세스가 실행되는 동안 생성되는 영역으로, 크기가 유동적   

1) **스택 영역** 

 * 함수 호출 후 되돌아올 메모리 주소를 스택에 구현   
 * 함수에서 사용되는 지역 변수를 스택에 구현   
 * 프로세스를 작동하기 위해 커널이 유지하는 자료 구조   
 * 프로세스가 사용하는 함수는 컴파일 시 결정, 호출 횟수는 실행 중 스레드가 결정   
 * 함수를 사용하지 않고 모든 코드를 main()에 넣으면 실행 속도가 가장 빨라지는 이유는 스택에 넣고 빼는 작업이 오버헤드이기 때문   

2) **힙 영역** 

 * 프로그램이 실행되는 동안 할당되는 일부 데이터를 저장하는 경우
 * 다른 대부분의 데이터는 데이터 영역에 할당되어 크기가 고정되지만, 동적 할당 데이터는 실행될 때 크기가 정해진다.    
